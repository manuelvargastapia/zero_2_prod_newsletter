use std::net::TcpListener;

use sqlx::PgPool;
use tracing::subscriber::set_global_default;
use tracing_bunyan_formatter::{BunyanFormattingLayer, JsonStorageLayer};
use tracing_log::LogTracer;
use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Registry};

use zero2prod::{configuration::get_configurations, startup::run};

// #[actix_web::main] is a procedural macro that allow running async code
// in main(). After expand it with cargo-expand, we can see that indeed
// the main() code passed to the compiler after #[actix_web::main] is
// synchronous. We are starting actix’s async runtime (actix_web::rt) and we
// are using it to drive the future returned by HttpServer::run to completion.
// In other words, the job of #[actix_web::main] is to give us the illusion of
// being able to define an asynchronous main while, under the hood, it just
// takes our main asynchronous body and writes the necessary boilerplate to
// make it run on top of actix’s runtime.
#[actix_web::main]
/// The only job of main() is try to call run() depending on its [Result] (Ok or Error).
async fn main() -> std::io::Result<()> {
    // Redirect all log's (tracing's log crate dependency) events to subscriber
    // (this is required because tracing show all the app-level logs but not
    // actix-web and other info)
    LogTracer::init().expect("Failed to set logger");

    // Setting to log the structured logs generated by the tracing crate's Span.
    // The EnvFilter struct discards spans based on their log levels ansd their origins.
    // We're falling back to printing all logs at info-level or above if the RUST_LOG env var has
    // not been set
    let env_filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info"));
    // The Layer trait helps with the composition of our processing pipeline for the spans.
    // We can combine multiple small layers to reach our goal.
    // JsonStorageLayer processes spans data and stores the associated metadata in a easy-to-comsume
    // JSON format for downstream layers.
    // BunyanFormattingLayer build on top of JsonStorageLayer and outputs log records in
    // bunyan-compoatible JSON format
    let formatting_layer = BunyanFormattingLayer::new("zero2prod".into(), std::io::stdout);
    // The Subscriber triat handles the Span's lifecycle.
    // Registry implements the Subscriber trait and takes care of collecting and store
    // spans metadata, recording relationships between spans, and tracking which spans are
    // active and which are closed
    let subscriber = Registry::default()
        // with() is a extension function provided by SubscriberExt
        .with(env_filter)
        .with(JsonStorageLayer)
        .with(formatting_layer);
    // Specify what subscriber should be used to process spans
    set_global_default(subscriber).expect("Failed to set subscriber.");

    // Load configurations from file before launching the server
    let configurations = get_configurations().expect("Failed to read configuration file.");

    // sqlx::PgPool is built around sqlx::PgConnection to handle multiple concurrent
    // queries through a connection pool
    let connection_pool = PgPool::connect(&configurations.database.generate_connection_string())
        .await
        .expect("Failed to connect to Postgres");

    let address = format!("127.0.0.1:{}", configurations.application_port);
    let listener = TcpListener::bind(address)?;

    run(listener, connection_pool)?.await?;
    Ok(())
}
